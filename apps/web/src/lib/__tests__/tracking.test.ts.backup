import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ChakraProvider } from '@chakra-ui/react';
import JobTracking from '@/components/Driver/JobTracking';
import { useTrackingUpdates, useAdminTrackingUpdates } from '@/hooks/useTrackingUpdates';

// Mock fetch
global.fetch = jest.fn();

// Mock navigator.geolocation
const mockGeolocation = {
  getCurrentPosition: jest.fn(),
  watchPosition: jest.fn(),
  clearWatch: jest.fn(),
};

Object.defineProperty(global.navigator, 'geolocation', {
  value: mockGeolocation,
  writable: true,
});

// Mock Pusher
jest.mock('pusher-js', () => ({
  default: jest.fn().mockImplementation(() => ({
    subscribe: jest.fn().mockReturnValue({
      bind: jest.fn(),
      unbind: jest.fn(),
      unsubscribe: jest.fn(),
    }),
    connection: {
      bind: jest.fn(),
    },
    disconnect: jest.fn(),
  })),
}));

// Mock environment variables
jest.mock('@/lib/env', () => ({
  env: {
    NEXT_PUBLIC_PUSHER_KEY: 'test-key',
    NEXT_PUBLIC_PUSHER_CLUSTER: 'eu',
    NEXT_PUBLIC_MAPBOX_TOKEN: 'test-mapbox-token',
  },
}));

const renderWithChakra = (component: React.ReactElement) => {
  return render(<ChakraProvider>{component}</ChakraProvider>);
};

describe('Tracking System Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (fetch as any).mockClear();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('JobTracking Component', () => {
    it('should render inactive state when job is not active', () => {
      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={false} 
        />
      );

      expect(screen.getByText('Job Tracking')).toBeInTheDocument();
      expect(screen.getByText('Inactive')).toBeInTheDocument();
      expect(screen.getByText('Tracking will be enabled when you start an active job')).toBeInTheDocument();
    });

    it('should render active tracking interface when job is active', () => {
      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      expect(screen.getByText('Live Tracking')).toBeInTheDocument();
      expect(screen.getByText('Inactive')).toBeInTheDocument();
    });

    it('should show location permission request when consent is not given', () => {
      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ locationConsent: false }),
      });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      expect(screen.getByText('Location Permission Required')).toBeInTheDocument();
      expect(screen.getByText('Enable Location Tracking')).toBeInTheDocument();
    });

    it('should handle location permission request', async () => {
      const mockPosition = {
        coords: {
          latitude: 51.5074,
          longitude: -0.1278,
          accuracy: 10,
        },
      };

      mockGeolocation.getCurrentPosition.mockImplementation((success) => {
        success(mockPosition);
      });

      (fetch as any)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ locationConsent: false }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ success: true }),
        });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      const enableButton = screen.getByText('Enable Location Tracking');
      fireEvent.click(enableButton);

      await waitFor(() => {
        expect(mockGeolocation.getCurrentPosition).toHaveBeenCalled();
      });
    });

    it('should handle location tracking start/stop', async () => {
      const mockPosition = {
        coords: {
          latitude: 51.5074,
          longitude: -0.1278,
          accuracy: 10,
        },
      };

      mockGeolocation.watchPosition.mockImplementation((success) => {
        success(mockPosition);
        return 123; // mock watch ID
      });

      (fetch as any)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ locationConsent: true }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ success: true }),
        });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Active')).toBeInTheDocument();
      });

      const stopButton = screen.getByText('Stop');
      fireEvent.click(stopButton);

      expect(mockGeolocation.clearWatch).toHaveBeenCalledWith(123);
    });

    it('should handle location update API calls', async () => {
      const mockPosition = {
        coords: {
          latitude: 51.5074,
          longitude: -0.1278,
          accuracy: 10,
        },
      };

      mockGeolocation.watchPosition.mockImplementation((success) => {
        success(mockPosition);
        return 123;
      });

      (fetch as any)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ locationConsent: true }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ success: true, trackingPingId: 'ping-123' }),
        });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      await waitFor(() => {
        expect(fetch).toHaveBeenCalledWith('/api/driver/tracking', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            bookingId: 'test-booking-123',
            latitude: 51.5074,
            longitude: -0.1278,
          }),
        });
      });
    });

    it('should handle location permission errors', async () => {
      mockGeolocation.getCurrentPosition.mockImplementation((success, error) => {
        error({ code: 1, message: 'Permission denied' });
      });

      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ locationConsent: false }),
      });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      const enableButton = screen.getByText('Enable Location Tracking');
      fireEvent.click(enableButton);

      await waitFor(() => {
        expect(screen.getByText('Location access denied. Please enable location permissions.')).toBeInTheDocument();
      });
    });
  });

  describe('Tracking API Tests', () => {
    it('should test driver tracking API POST endpoint', async () => {
      const mockResponse = {
        success: true,
        trackingPingId: 'ping-123',
        timestamp: new Date().toISOString(),
      };

      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse,
      });

      const response = await fetch('/api/driver/tracking', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          bookingId: 'test-booking-123',
          latitude: 51.5074,
          longitude: -0.1278,
        }),
      });

      const data = await response.json();
      expect(data).toEqual(mockResponse);
    });

    it('should test driver tracking API GET endpoint', async () => {
      const mockResponse = {
        success: true,
        trackingPings: [
          {
            id: 'ping-1',
            lat: 51.5074,
            lng: -0.1278,
            createdAt: new Date().toISOString(),
          },
        ],
      };

      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse,
      });

      const response = await fetch('/api/driver/tracking?bookingId=test-booking-123');
      const data = await response.json();
      expect(data).toEqual(mockResponse);
    });

    it('should test admin tracking API endpoint', async () => {
      const mockResponse = {
        success: true,
        booking: {
          id: 'booking-123',
          reference: 'ABC123',
          status: 'IN_PROGRESS',
          routeProgress: 60,
          currentLocation: {
            lat: 51.5074,
            lng: -0.1278,
            timestamp: new Date().toISOString(),
          },
        },
      };

      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse,
      });

      const response = await fetch('/api/admin/orders/ABC123/tracking');
      const data = await response.json();
      expect(data).toEqual(mockResponse);
    });

    it('should test public tracking API endpoint', async () => {
      const mockResponse = {
        id: 'booking-123',
        reference: 'ABC123',
        status: 'IN_PROGRESS',
        routeProgress: 60,
        currentLocation: {
          lat: 51.5074,
          lng: -0.1278,
          timestamp: new Date().toISOString(),
        },
      };

      (fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse,
      });

      const response = await fetch('/api/track/ABC123?tracking=true');
      const data = await response.json();
      expect(data).toEqual(mockResponse);
    });
  });

  describe('Tracking Hooks Tests', () => {
    it('should test useTrackingUpdates hook', () => {
      const { result } = renderHook(() => useTrackingUpdates({
        bookingId: 'test-booking-123',
        enabled: true,
      }));

      expect(result.current.updates).toEqual([]);
      expect(result.current.isConnected).toBe(false);
      expect(result.current.error).toBeNull();
      expect(typeof result.current.sendLocationUpdate).toBe('function');
      expect(typeof result.current.clearUpdates).toBe('function');
    });

    it('should test useAdminTrackingUpdates hook', () => {
      const { result } = renderHook(() => useAdminTrackingUpdates());

      expect(result.current.allUpdates).toEqual({});
      expect(result.current.isConnected).toBe(false);
      expect(result.current.error).toBeNull();
      expect(typeof result.current.getBookingUpdates).toBe('function');
      expect(typeof result.current.getLatestBookingUpdate).toBe('function');
      expect(typeof result.current.getAllLatestUpdates).toBe('function');
    });
  });

  describe('Error Handling Tests', () => {
    it('should handle API errors gracefully', async () => {
      (fetch as any).mockRejectedValueOnce(new Error('Network error'));

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Location Update Failed')).toBeInTheDocument();
      });
    });

    it('should handle geolocation not available', () => {
      // Mock geolocation as undefined
      Object.defineProperty(global.navigator, 'geolocation', {
        value: undefined,
        writable: true,
      });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      expect(screen.getByText('Geolocation not available')).toBeInTheDocument();
    });

    it('should handle invalid location coordinates', async () => {
      const mockPosition = {
        coords: {
          latitude: 1000, // Invalid latitude
          longitude: -0.1278,
          accuracy: 10,
        },
      };

      mockGeolocation.watchPosition.mockImplementation((success) => {
        success(mockPosition);
        return 123;
      });

      (fetch as any)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ locationConsent: true }),
        })
        .mockResolvedValueOnce({
          ok: false,
          json: async () => ({ error: 'Location coordinates out of valid range' }),
        });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      await waitFor(() => {
        expect(screen.getByText('Location Update Failed')).toBeInTheDocument();
      });
    });
  });

  describe('Performance Tests', () => {
    it('should limit tracking updates frequency', async () => {
      const mockPosition = {
        coords: {
          latitude: 51.5074,
          longitude: -0.1278,
          accuracy: 10,
        },
      };

      mockGeolocation.watchPosition.mockImplementation((success) => {
        success(mockPosition);
        return 123;
      });

      (fetch as any)
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ locationConsent: true }),
        })
        .mockResolvedValue({
          ok: true,
          json: async () => ({ success: true }),
        });

      renderWithChakra(
        <JobTracking 
          bookingId="test-booking-123" 
          isActive={true} 
        />
      );

      // Wait for initial setup
      await waitFor(() => {
        expect(fetch).toHaveBeenCalledTimes(2); // Initial consent check + first location update
      });

      // Simulate rapid position updates
      for (let i = 0; i < 5; i++) {
        mockGeolocation.watchPosition.mock.calls[0][0](mockPosition);
      }

      // Should not exceed reasonable update frequency
      await waitFor(() => {
        expect(fetch).toHaveBeenCalledTimes(2); // Should not have made additional calls immediately
      });
    });
  });

  describe('Security Tests', () => {
    it('should validate location coordinates', async () => {
      const invalidCoordinates = [
        { lat: 1000, lng: -0.1278 }, // Invalid latitude
        { lat: 51.5074, lng: 2000 }, // Invalid longitude
        { lat: -100, lng: -0.1278 }, // Invalid latitude
        { lat: 51.5074, lng: -200 }, // Invalid longitude
      ];

      for (const coords of invalidCoordinates) {
        const response = await fetch('/api/driver/tracking', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            bookingId: 'test-booking-123',
            latitude: coords.lat,
            longitude: coords.lng,
          }),
        });

        expect(response.status).toBe(400);
        const data = await response.json();
        expect(data.error).toContain('Location coordinates out of valid range');
      }
    });

    it('should require authentication for tracking endpoints', async () => {
      const endpoints = [
        '/api/driver/tracking',
        '/api/admin/orders/ABC123/tracking',
      ];

      for (const endpoint of endpoints) {
        const response = await fetch(endpoint, {
          method: 'GET',
        });

        expect(response.status).toBe(401);
      }
    });
  });
});
